use enum_assoc::Assoc;
use serde::Deserialize;
use strum::Display;

use crate::{app::Mode, result::Results};

/// Actions generated by the app
#[derive(Display, Debug, Clone, PartialEq, Eq)]
pub enum AppAction {
    Tick,
    Render,
    Resize(u16, u16),
    Resume,
    ClearScreen,
    Error(String),
    Warning(String),
    Info(String),
    Task(TaskAction),
    Search(String),
    UserAction(UserAction),
}

/// Actions generated by the user
///
/// In the user keybindings config file, they may be stored as:
/// ```toml
/// "<key>" = "UnitAction"
/// # or
/// "<key>" = { "OneArgAction" = "SingleArg" }
/// # or
/// "<key>" = { "ManyArgAction" = ["Many", "Args"] }
/// ```
#[derive(Assoc, Deserialize, Display, Debug, Clone, PartialEq, Eq)]
#[func(pub fn name(&self) -> String { self.to_string() })]
pub enum UserAction {
    Quit,
    Suspend,
    Up,
    Down,
    Left,
    Right,
    Top,
    Bottom,
    InsertLeft,
    InsertRight,
    InsertNextWord,
    InsertPrevWord,
    Submit,
    #[assoc(name = format!("{self}({_0})"))]
    SetMode(Mode),
    WhichKey,
    #[assoc(name = format!("{self}({_0})"))]
    NotifyInfo(String),
    #[assoc(name = format!("{self}({_0})"))]
    NotifyError(String),
    #[assoc(name = format!("{self}({_0})"))]
    NotifyWarning(String),
    ClearNotifications,
}

/// Actions generated by tasks
///
/// General interface for capturing results across threads
#[derive(Display, Debug, Clone, PartialEq, Eq)]
pub enum TaskAction {
    SourceResults(Option<Results>),
}
